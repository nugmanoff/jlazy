# JLazy
Very lazy incremental compilation for Javac compiler.

# Предисловие

Ребят, привет!

Хотел сказать спасибо за самую интересно-проведенную неделю (в инженерном плане) за очень долгое время.
За эту неделю я постиг больше подкапотных глубин ежедневных вещей, чем за всю карьеру, наверное.
И самое главное, я окончательно убедился что мне это очень нравится.

И что я окончательно устал от тривиальных задач, которые я решал всё это время. 

Когда я первый раз прочитал задание, я подумал: "О, я точно смогу это сделать, и смогу это сделать *круто*".
И это самое *круто* меня подвело, потому что я не учёл, что:
0. Практически абсолютно новый домен каких-то деталей, бизнес-логики, слов и сущностей.
1. Я никогда не изучал настолько большие и сложные кодовые базы
2. Последний раз я писал на Java 4 года назад. 
3. Во мне сыграл разработческий максимализм, и желание сделать всё круто и сразу ([BDUF](https://knowledge21.com/blog/bduf/)). И я неправильно распределил свои ограниченные усилия.

Я не отговариваюсь :) Это скорее ответы на вопрос: "А почему ты этого всего не сделал?", который может у вас возникнуть при чтении моих следующих набросков по идеям.
Скорее всего все четыре фактора описанных сверху являются индикаторами определённой незрелости, которые я списываю на максимализм.

# Инструкция

### Структура:
- `jlazy` основная папка с CLI 
- `jlazy-test` из-за отсутствия тестов, эта папка служит неким тестовым проектом, на котором можно тестировать инкрементальную компилияцию.

### Как запускать:
1. Открыть папку `jlazy` через Intellij IDEA.
2. Запустить один раз `Main` чтобы создалась схема.
3. Настроить схему `Main` со следующими настройками:
- Working directory: тут надо указать папку `jlazy-test`
- Arguments: сюда передаём `--dir src/` и `--classpath src/`
4. По логам можно будет понять результат выполнения.

# Как нужно было делать

- Сделать упор на точности алгоритма анализа зависимостей и начать с него. Почему не на скорости? Потому что, мне кажется, точный алгоритм легче сделать эффективнее,
чем быстрый алгоритм сделать точным. Начать работу над алгоритмом стоило с написания изолированных юнит тестов (которые я просто руками проверял, 
хотя понимал, что я выиграю на этом. Но в итоге за ограничений по времени побоялся тратиться на это). 

- Спроектировать контракты (интерфейсы) переходов из одного этапа компиляции в другой. И в один момент времени фокусироваться только на каждом из этапов.
Изолировать этапы друг от друга, чтобы можно было оставлять какие-то наивные (простые, неэффективные) реализации некоторых этапов, жертвую в пользу точности алгоритма.
(Я потратил очень много времени на каких-то промежуточных этапах пытаясь их сразу с первого раза всех вместе сделать "крутыми")

- Быстрее начать набрасывать первую реализацию. Я около 30-40% времени потерял на изучение, чтение и погружение. Пытался сразу понять - как сделать круто (не понимая при этом, как сделать некруто).
Понять, что понимание многих деталей придёт в процессе, а не при изучении. 

# Что можно было сделать лучше 

Всё. Шучу)

### Умнее справляться с константами

Сейчас 

### Ранний выход при определенных кейсах

### Считать класс грязным, только если его ABI изменился

### Daemon для наблюдения за изменениями в файлах

### Поддержка Jar и нескольких записей в Classpath

### Annotations

### Поддержка метафайлов (module-info, package-info)

### Symlink 

### Resources

### Gradle фиксы
https://github.com/gradle/gradle/issues/8590

### Написать тесты

Изолированные тесты на каждый из этапов и интеграционные тесты на связки между этапами. И простенькие E2E тесты по работе с итоговым продуктом.

