# JLazy
Very lazy incremental compilation for Javac compiler.

# Предисловие

Ребят, привет!

Хотел сказать спасибо за самую интересно-проведенную неделю (в инженерном плане) за очень долгое время.
За эту неделю я постиг больше подкапотных глубин ежедневных вещей, чем за всю карьеру, наверное.
И самое главное, я окончательно убедился что мне это очень нравится.

И что я окончательно устал от тривиальных задач, которые я решал всё это время. 

Когда я первый раз прочитал задание, я подумал: "О, я точно смогу это сделать, и смогу это сделать *круто*".
И это самое *круто* меня подвело, потому что я не учёл, что:
0. Практически абсолютно новый домен каких-то деталей, бизнес-логики, слов и сущностей.
1. Я никогда не изучал настолько большие и сложные кодовые базы
2. Последний раз я писал на Java 4 года назад. 
3. Во мне сыграл разработческий максимализм, и желание сделать всё круто и сразу ([BDUF](https://knowledge21.com/blog/bduf/)). И я неправильно распределил свои ограниченные усилия.

Я не отговариваюсь :) Это скорее ответы на вопрос: "А почему ты этого всего не сделал?", который может у вас возникнуть при чтении моих следующих набросков по идеям.
Скорее всего все четыре фактора описанных сверху являются индикаторами определённой незрелости, которые я списываю на максимализм.

# Инструкция

### Структура:
- `jlazy` основная папка с CLI 
- `jlazy-test` из-за отсутствия тестов, эта папка служит неким тестовым проектом, на котором можно тестировать инкрементальную компилияцию.

### Как запускать:
1. Открыть папку `jlazy` через Intellij IDEA.
2. Запустить один раз `Main` чтобы создалась схема.
3. Настроить схему `Main` со следующими настройками:
- Working directory: тут надо указать папку `jlazy-test`
- Arguments: сюда передаём `--dir src/` и `--classpath src/`
4. По логам можно будет понять результат выполнения.

# Как нужно было делать

- Сделать упор на точности алгоритма анализа зависимостей и начать с него. Почему не на скорости? Потому что, мне кажется, точный алгоритм легче сделать эффективнее,
чем быстрый алгоритм сделать точным. Начать работу над алгоритмом стоило с написания изолированных юнит тестов (которые я просто руками проверял, 
хотя понимал, что я выиграю на этом. Но в итоге за ограничений по времени побоялся тратиться на это). 

- Спроектировать контракты (интерфейсы) переходов из одного этапа компиляции в другой. И в один момент времени фокусироваться только на каждом из этапов.
Изолировать этапы друг от друга, чтобы можно было оставлять какие-то наивные (простые, неэффективные) реализации некоторых этапов, жертвую в пользу точности алгоритма.
(Я потратил очень много времени на каких-то промежуточных этапах пытаясь их сразу с первого раза всех вместе сделать "крутыми")

- Быстрее начать набрасывать первую реализацию. Я около 30-40% времени потерял на изучение, чтение и погружение. Пытался сразу понять - как сделать круто (не понимая при этом, как сделать некруто).
Понять, что понимание многих деталей придёт в процессе, а не при изучении. 

# Что можно было сделать лучше 

Всё. Шучу)

### Умнее справляться с константами

Сейчас в процессе анализа класса при выявлении публичной константы (`public static final`) - этот класс автоматически марикруется как потенциально зависимый от всех. Потому что нет механизма отслеживания классов зависимых от этой константы. Здесь есть определённые проблемы с тем, что Javac производит некоторые оптимизации и `inline`-ит константы. Я откопал этот [тикет](https://bugs.openjdk.java.net/browse/JDK-7153958) - и из него следует, что в принципе есть возможность отследить такие константы и умене их хэндлить. Как минимум в рамках OpenJDK Javac. По GNU GCJ, Eclipse ECJ никакой информации о такой возможности у меня нет.

### Считать класс грязным, только если его ABI изменился

Считать класс "грязным", не просто если хэш его файла изменился, а если изменился его ABI (в противном случае, перекомпиляция необязательна). Для этого нужно трэкать непосредственные изменения которые произошли в классе и выявлять ломают ли они ABI совместимость или нет. В случае если ABI файла изменился, мы проходимся по всем зависимым файлам и тоже выявляем изменились ли их ABI, и повторяем так до тех пор, пока ABI всех файлов исследуемых на данный момент не стабилизируется (Под стабильным ABI я имею ввиду обратно-совместимый ABI с прошлой версией файла). Соответственно после точки стабилизации дальнейшие рекурсивные итерации выявления зависимостей будут бессмысленны и можно останавливаться.

Как научиться понимать изменился ли ABI?

Можно попробовать один из двух методов анализа изменений файла:
1. Основанный на тексте. Использовать какой-нибудь традиционный diffing алгоритм вроде Алгоритма Майерса. И выявлять изменения в символах которые аффектят ABI.
2. Основанный на AST. Конструировать AST для каждого файла, и анализировать уже его для более точного определения характера изменений (ломают ли ABI или нет).

### Daemon для наблюдения за изменениями в файлах

Для того чтобы каждый раз не считать хэши всех файлов перед компиляцией и не сравнивать их с хэшами всех файлов с прошлый компиляции - можно запустить демон-процесс который будет наблюдать за ивентами в файловой системе в указанной директории. В Java есть такая [штука](https://docs.oracle.com/javase/tutorial/essential/io/notification.html). Но я не уверен насчёт memory implications такого решения.

### Поддержка Jar и нескольких записей в Classpath

1. Поддержать Jar-ы сами по себе не так сложно, это в принципе те же самые директории, просто заархивированные и с ресурсами.
2. Но при поддержке Jar возникает вопрос поддержания нескольких записей в classpath, типа `--classpath jar1:jar2`

Из второго пункта вытекает тот факт, что нужно следить за изменениями в classpath, в ответ на вопросу почему прикреплю цитату из переписики в Slack:
> Представим кейс, что `класс А` имеется в двух разных jar-ках, но с разным ABI. 
Порядок итемов в classpath - важен. Он определяет из какой из jar-ок подгрузится `класс A`.
И чтобы хэндлить такой кейс, нужно отслеживать из какой jar-ки был использован `класс А`, чтобы правильно определить, что именно нужно перекомпилировать.

Я вижу следующие варианты решения:

1. Наивный. Предположить, что изменения classpath-a это явление не частое и просто триггерить полную перекомпиляцию при каждом изменении. 
2. Анализировать на наличие дупликатных классов в записях classpath-a, если нет дупликатов - то значит, нам можно "не париться" насчёт изменений в classpath. 
3. Расширить [ClassLoader](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html) и в случае успешной компиляции "запоминать" откуда импортится класс который используется. И при следующей компиляции лоудить именно его, тем самым игнорируя какие-либо изменения в classpath.

### Annotations

Если честно, у меня просто не хватило времени достаточно узнать про то как работают аннотации под капотом, чтобы их захэндлить. Но думаю, никаких особых сложностей в этом нет, это просто еще один тип зависимости между классами. Плюс добавляется дополнительная сущность в процесс обработки в виде процессора аннотаций. И еще нужно отличать compile time аннотации от runtime аннотаций (это можно определяется с помощью Retention policy).

### Поддержка метафайлов (module-info, package-info)

Есть такие штуки как module info и package info которые несут в себе определенные метаданные (зависимости модуля, интерфейс модуля и т.д.), которые могут влиять на процесс анализа зависимостей.

### Symlinks, paths handling

Сделать проверку на резолюшн симлинков в файлах которые используются как сорсы. Качественнее нормализовывать пути, чтобы этот инструмент был более отказо-устойчив и лучше портируем. 

### Написать тесты

Изолированные тесты на каждый из этапов и интеграционные тесты на связки между этапами. И простенькие E2E тесты по работе с итоговым продуктом.

### Remote cache / remote compilation

Это наверное будет более актуально для больших проектов. 

Представим сценарий, когда у разработчиков компы слабые, а проект который он билдит очень тяжелый.
Тогда можно триггерить компиляцию на удалённой машине (которая мощнее), и потом подтягивать по сети кэши и продукты компиляции, для запуска локально.
Для простенького первого решения в этой области даже не нужно писать много своих велосипедов. Достаточно (надеюсь, что достаточно) заюзать что-то вроде [JCS](https://commons.apache.org/proper/commons-jcs/) и что-то вроде [rsync](https://linux.die.net/man/1/rsync)
